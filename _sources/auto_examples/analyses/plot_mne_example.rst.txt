.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_analyses_plot_mne_example.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_analyses_plot_mne_example.py:


Topographical Analyses with MNE
===============================

How to use FOOOF with MNE, doing a topographical analysis.

This tutorial requires that you have `MNE <https://mne-tools.github.io/>`_
installed.

If you don't already have MNE, you can follow instructions to get it
`here <https://mne-tools.github.io/stable/getting_started.html>`_.

For this example, we will explore how to apply FOOOF to data loaded and managed with MNE,
and how to plot topographies of FOOOF outputs. To do so, here we will use continuous data.


.. code-block:: default


    # General imports
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib import cm, colors, colorbar

    # Import MNE, as well as the MNE sample dataset
    import mne
    from mne import io
    from mne.datasets import sample
    from mne.viz import plot_topomap
    from mne.time_frequency import psd_welch

    # FOOOF imports
    from fooof import FOOOFGroup
    from fooof.bands import Bands
    from fooof.analysis import get_band_peak_fg
    from fooof.plts.spectra import plot_spectrum








Load & Check MNE Data
---------------------

We will use the
`MNE sample dataset <https://mne.tools/stable/overview/datasets_index.html?#sample>`_
which is a combined MEG/EEG recording with an audiovisual task.

First we will load the dataset from MNE, have a quick look at the data,
and extract the EEG data that we will use for this example.

Note that if you are running this locally, the following cell will download
the example dataset, if you do not already have it.



.. code-block:: default


    # Get the data path for the MNE example data
    raw_fname = sample.data_path() + '/MEG/sample/sample_audvis_filt-0-40_raw.fif'
    event_fname = sample.data_path() + '/MEG/sample/sample_audvis_filt-0-40_raw-eve.fif'

    # Load the example MNE data
    raw = mne.io.read_raw_fif(raw_fname, preload=True, verbose=False)









.. code-block:: default


    # Select EEG channels from the dataset
    raw = raw.pick_types(meg=False, eeg=True, eog=False, exclude='bads')









.. code-block:: default


    # Set the reference to be average reference
    raw = raw.set_eeg_reference()








Dealing with NaN Values
-----------------------

One thing to keep in mind when running FOOOF, and extracting bands of interest,
is that there is no guarantee that FOOOF will detect peaks in any given range.

We consider this a pro, since FOOOF is able to adjudicate whether there is evidence
of oscillatory power within a given band, but it does also mean that sometimes results
for a given band can be NaN, which doesn't always work very well with further
analyses that we may want to do.

To be able to deal with nan-values, we will define a helper function to
check for NaN values and apply a specified policy for how to deal with them.



.. code-block:: default


    def check_nans(data, nan_policy='zero'):
        """Check an array for nan values, and replace, based on policy."""

        # Find where there are nan values in the data
        nan_inds = np.where(np.isnan(data))

        # Apply desired nan policy to data
        if nan_policy == 'zero':
            data[nan_inds] = 0
        elif nan_policy == 'mean':
            data[nan_inds] = np.nanmean(data)
        else:
            raise ValueError('Nan policy not understood.')

        return data








Calculating Power Spectra
-------------------------

To fit FOOOF models, we need to convert the time-series data we have loaded in
frequency representations - meaning we have to calculate power spectra.

To do so, we will leverage the time frequency tools available with MNE,
in the `time_frequency` module. In particular, we can use the :func:`psd_welch` function,
that takes in MNE data objects and calculates and returns power spectra.



.. code-block:: default


    # Calculate power spectra across the the continuous data
    spectra, freqs = psd_welch(raw, fmin=1, fmax=40, tmin=0, tmax=250,
                               n_overlap=150, n_fft=300)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Effective window size : 1.998 (s)




Calculating FOOOF Models
------------------------

Now that we have power spectra, we can fit some FOOOF models.

Since we have multiple power spectra, we will use the :obj:`FOOOFGroup` object.



.. code-block:: default


    # Initialize a FOOOFGroup object, with desired settings
    fg = FOOOFGroup(peak_width_limits=[1, 6], min_peak_height=0.15,
                    peak_threshold=2., max_n_peaks=6, verbose=False)

    # Define the frequency range to fit
    freq_range = [1, 30]









.. code-block:: default


    # Fit the FOOOF model across all channels
    fg.fit(freqs, spectra, freq_range)









.. code-block:: default


    # Check the overall results of the group fits
    fg.plot()




.. image:: /auto_examples/analyses/images/sphx_glr_plot_mne_example_001.png
    :class: sphx-glr-single-img





Plotting Topographies
---------------------

Now that we have our power spectrum models calculated across all channels,
let's start by plotting topographies of some FOOOF features.

To do so, we can leverage the fact that both MNE and FOOOF preserve data order.
So, when we calculated power spectra, our output spectra kept the channel order
that is described in the MNE data object, and so did our :obj:`FOOOFGroup` object.

That means that to plot our topography, we can use the MNE :func:`plot_topomap`
function, passing in extracted data for FOOOF features per channel, and
using the MNE object to define the corresponding channel locations.


Plotting Periodic Topographies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lets start start by plotting some periodic FOOOF features.

To do so, we will use to :obj:`Bands` object to manage some band definitions,
and some FOOOF analysis utilities to extracts peaks from bands of interest.



.. code-block:: default


    # Define frequency bands of interest
    bands = Bands({'theta': [3, 7],
                   'alpha': [7, 14],
                   'beta': [15, 30]})









.. code-block:: default


    # Extract alpha peaks from the FOOOFGroup results
    alphas = get_band_peak_fg(fg, bands.alpha)

    # Extract the power values from the FOOOF peaks
    alpha_pw = alphas[:, 1]









.. code-block:: default


    # Plot the topography of alpha power
    plot_topomap(alpha_pw, raw.info, cmap=cm.viridis, contours=0);




.. image:: /auto_examples/analyses/images/sphx_glr_plot_mne_example_002.png
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    (<matplotlib.image.AxesImage object at 0x10176b46d0>, <matplotlib.contour.QuadContourSet object at 0x10176be350>)



And there we have it, our first topography from FOOOF, showing alpha power!

The topography makes sense, as we can see a centro-posterior distribution.

Now we can extend this to plot the power of each of our other defined frequency bands.



.. code-block:: default


    # Plot the topographies across different frequency bands
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))
    for ind, (label, band_def) in enumerate(bands):

        # Get the power values across channels for the current band
        band_power = check_nans(get_band_peak_fg(fg, band_def)[:, 1])

        # Create a topomap for the current oscillation band
        mne.viz.plot_topomap(band_power, raw.info, cmap=cm.viridis, contours=0,
                             axes=axes[ind], show=False);

        # Set the plot title
        axes[ind].set_title(label + ' power', {'fontsize' : 20})




.. image:: /auto_examples/analyses/images/sphx_glr_plot_mne_example_003.png
    :class: sphx-glr-single-img





You might notice that the topographies of some of the bands look a little 'patchy'.
This is because we are setting any channels for which we did not find a peak as zero
with our `check_nan` approach. Note that is also a single subject analysis.


Since we have the FOOOF models for each of our channels, we can also explore what
these peaks look like in the underlying power spectra.

Next, lets check the power spectra for the largest detected peaks within each band.



.. code-block:: default


    fig, axes = plt.subplots(1, 3, figsize=(15, 6))
    for ind, (label, band_def) in enumerate(bands):

        # Get the power values across channels for the current band
        band_power = check_nans(get_band_peak_fg(fg, band_def)[:, 1])

        # Plot the extracted FOOOF model for the model with the most band power
        fg.get_fooof(np.argmax(band_power)).plot(ax=axes[ind], add_legend=False)

        # Set some plot aesthetics & plot title
        axes[ind].yaxis.set_ticklabels([])
        axes[ind].set_title('biggest ' + label + ' peak', {'fontsize' : 16})




.. image:: /auto_examples/analyses/images/sphx_glr_plot_mne_example_004.png
    :class: sphx-glr-single-img





Plotting Aperiodic Topographies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next up, let's plot the topography of the aperiodic exponent.

To do so, we can simply extract the aperiodic features from our FOOOF object,
and plot them.



.. code-block:: default


    # Extract aperiodic exponent values from the FOOOFGroup
    exps = fg.get_params('aperiodic_params', 'exponent')









.. code-block:: default


    # Plot the topography of aperiodic exponents
    plot_topomap(exps, raw.info, cmap=cm.viridis, contours=0)




.. image:: /auto_examples/analyses/images/sphx_glr_plot_mne_example_005.png
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    (<matplotlib.image.AxesImage object at 0x1019581e50>, <matplotlib.contour.QuadContourSet object at 0x10195c08d0>)



In the topography above, we can see that there is a fair amount of variation
across the scalp in terms of aperiodic exponent value, and there seems to be some
spatial structure to it.

To visualize how much the exponent values vary, we can again plot some example power
spectra, in this case extracting those with the highest and lower exponent values.



.. code-block:: default


    # Compare the power spectra between low and high exponent channels
    fig, ax = plt.subplots(figsize=(8, 6))
    plot_spectrum(fg.freqs, fg.get_fooof(np.argmin(exps)).power_spectrum,
                  ax=ax, label='Low Exponent')
    plot_spectrum(fg.freqs, fg.get_fooof(np.argmax(exps)).power_spectrum,
                  ax=ax, label='High Exponent')




.. image:: /auto_examples/analyses/images/sphx_glr_plot_mne_example_006.png
    :class: sphx-glr-single-img





Conclusion
----------

In this example, we have seen how to apply FOOOF models to data that is managed
and processed with MNE.


Sphinx settings:
sphinx_gallery_thumbnail_number = 2


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.626 seconds)


.. _sphx_glr_download_auto_examples_analyses_plot_mne_example.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_mne_example.py <plot_mne_example.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_mne_example.ipynb <plot_mne_example.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
